# -*- coding: utf-8 -*-
"""Soil Crop Classification - Original.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yf0tyb5YDy3BAnOB5Ot0leHzZaodjCXk
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
import cv2
import warnings
warnings.filterwarnings("ignore")
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D,MaxPooling2D,Flatten,Dense,Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping,ModelCheckpoint

from google.colab import drive
drive.mount('/content/gdrive')

dataset_dir = "/content/gdrive/MyDrive/Soil types"

# Output folder for resized images
output_folder = "/content/gdrive/MyDrive/Resized_Soil"

# Desired dimensions for resized images
new_width = 224
new_height = 224

if not os.path.exists(output_folder):
    os.makedirs(output_folder)

for soil in os.listdir(dataset_dir):
  for filename in os.listdir(os.path.join(dataset_dir, soil)):
    if filename.endswith(".jpg") or filename.endswith(".png") or filename.endswith(".jpeg"):
        # Read the image
        image_path = os.path.join(dataset_dir, soil, filename)
        img = cv2.imread(image_path)

        resized_img = cv2.resize(img, (new_width, new_height))

        # Write the resized image to the output folder
        o_dir = os.path.join(output_folder,soil)
        if not os.path.exists(o_dir):
          os.makedirs(o_dir)
        output_path = os.path.join(o_dir, filename)
        plt.imshow(resized_img)
        plt.show()
        cv2.imwrite(output_path, resized_img)
        print(f"{output_path}{filename} resized and saved successfully.")

datagen = ImageDataGenerator(
    rescale=1/255.0,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

train_set = datagen.flow_from_directory(
    output_folder,
    subset='training',
    batch_size=32,
    target_size=(224, 224),
    class_mode='categorical',
    shuffle=True
)

model = Sequential([
    Conv2D(32,(3,3),activation='relu',input_shape=(224,224,3)),
    MaxPooling2D((2,2)),
    Conv2D(64,(3,3),activation='relu'),
    MaxPooling2D((2,2)),
    Conv2D(128,(3,3),activation='relu'),
    MaxPooling2D((2,2)),
    Conv2D(128,(3,3),activation='relu'),
    MaxPooling2D((2,2)),
    Flatten(),
    Dense(512,activation='relu'),
    Dropout(0.5),
    Dense(5,activation='softmax')
])

model.compile(optimizer=Adam(learning_rate=0.0001),loss='categorical_crossentropy',metrics=['accuracy'])

es = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)
mc = ModelCheckpoint('model.h5',monitor='val_loss',mode='min',verbose=1,save_best_only=True)

model.fit(train_set,epochs=30,batch_size=32,callbacks=[es,mc])

model.save('model.h5')

from keras.models import load_model
saved_model = load_model('model.h5')















# Function for crop prediction based on soil type
def crop_prediction(soil_type):
    crop_mapping = {
        'Black Soil': ['Cotton','Wheat','Groundnut','Tobacco','Chillies','Oilseeds','Rice','Ragi','Maize','Sugarcane','Citrus','Linseed','Sunflower','Millets'],
        'Cinder Soil': ['Roses','Succulents','Cactus','Adenium','Snake Plant','Orchids','Bonsai'],
        'Laterite Soil': ['Tea','Coffee','Rubber','Cashew','Coconut','Wheat','Rice','Pulses','Cotton'],
        'Peat Soil': ['Potatoes','Sugar Beets','Lettuce','Onions','Carrots','Celery'],
        'Yellow Soil': ['Wheat','Cotton','Oilseeds','Millets','Tobacco','Pulses','Maize','Groundnut','Rice','Mango','Orange','Potato']
    }
    return crop_mapping.get(soil_type,[])

# Make predictions
test_image = cv2.imread('/content/gdrive/MyDrive/Resized_Soil/Laterite Soil/10.jpg',cv2.IMREAD_COLOR)
test_image = cv2.cvtColor(test_image,cv2.COLOR_BGR2RGB)
test_image = cv2.resize(test_image,(224,224))
plt.imshow(test_image)
test_image = np.expand_dims(test_image, axis=0)
result = saved_model.predict(test_image)

# Map predicted indices to class names
# Invert the class_indices dictionary to map indices to class names
class_names = {v: k for k, v in train_set.class_indices.items()}

# Map predicted index to class name
prediction = class_names[np.argmax(result)]

print(prediction)
crop_prediction(prediction)

